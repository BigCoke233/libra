class $1e566b6277893a87$export$2e2bcd8739ae039 {
    zIndex = 900;
    zIndexHidden = -100;
    constructor(){
        const overlay = document.createElement('div');
        overlay.id = 'libo-overlay';
        overlay.classList.add('libo-overlay');
        // initialized state
        overlay.style.zIndex = this.zIndexHidden;
        overlay.style.opacity = '0';
        this.element = overlay;
        document.body.appendChild(overlay);
        return this;
    }
    show() {
        this.element.style.opacity = '1';
        this.element.style.zIndex = this.zIndex;
    }
    hide() {
        this.element.style.opacity = '0';
        this.element.style.zIndex = '-100';
    }
}


class $ec04822463bc4394$export$2e2bcd8739ae039 {
    zIndex = '1000';
    isOpen = false;
    /**
   * ============
   * Constructors
   * ============
   */ constructor(image){
        this.create(image);
        this.calculateStartsAndFinals();
        return this;
    }
    create(image) {
        // create shadow image
        const shadowImage = document.createElement('img');
        shadowImage.src = image.src;
        shadowImage.id = `libo-shadow-${image.id}`;
        shadowImage.classList.add('libo-shadow');
        // style and position shadow image
        shadowImage.style.top = image.offsetTop;
        shadowImage.style.left = image.offsetLeft;
        shadowImage.style.width = image.offsetWidth;
        shadowImage.style.height = image.offsetHeight;
        shadowImage.style.zIndex = this.zIndex;
        document.body.appendChild(shadowImage);
        this.element = shadowImage;
    }
    calculateStartsAndFinals() {
        // get starting state
        const s = {
            top: this.element.offsetTop,
            left: this.element.offsetLeft,
            width: this.element.offsetWidth,
            height: this.element.offsetHeight
        };
        const f = {};
        const margin = 50;
        // calculate final size
        const nw = this.element.naturalWidth;
        const nh = this.element.naturalHeight;
        const ratio = nw / nh;
        const ww = window.innerWidth - margin * 2;
        const wh = window.innerHeight - margin * 2;
        f.width = Math.min(nw, ww);
        f.height = f.width / ratio;
        if (f.height >= wh) {
            f.height = wh;
            f.width = f.height * ratio;
        }
        // calculate final position
        f.left = (ww - f.width) / 2 + margin;
        f.top = (wh - f.height) / 2 + margin;
        this.finalState = f;
        this.startingState = s;
    }
    /**
   * ============
   * Actions
   * ============
   */ open() {
        this.isOpen = true;
        this.animate(this.startingState, this.finalState);
    }
    close() {
        this.isOpen = false;
        this.animate(this.finalState, this.startingState);
    }
    animate(starts, finals) {
        // Set up the interval for smooth transition
        const steps = 20; // Number of steps for smoothness
        let step = 0;
        // Using requestAnimationFrame for smoother animation
        const frame = ()=>{
            // Calculate the progress (from 0 to 1)
            const progress = step / steps;
            // Interpolate the current values based on progress
            const currentTop = starts.top + (finals.top - starts.top) * progress;
            const currentLeft = starts.left + (finals.left - starts.left) * progress;
            const currentWidth = starts.width + (finals.width - starts.width) * progress;
            const currentHeight = starts.height + (finals.height - starts.height) * progress;
            // Update the element's style
            this.element.style.top = `${currentTop}px`;
            this.element.style.left = `${currentLeft}px`;
            this.element.style.width = `${currentWidth}px`;
            this.element.style.height = `${currentHeight}px`;
            // Log current size for debugging
            console.log(`Step ${step}: ${currentTop}, ${currentLeft}`);
            // Increase the step count
            step++;
            // Continue animating until we reach the final step
            if (step <= steps) requestAnimationFrame(frame);
            else {
                this.element.classList.toggle('open');
                if (!this.isOpen) this.destroyItself();
            }
        };
        // Start the animation
        requestAnimationFrame(frame);
    }
    placeItself() {
        document.body.appendChild(this.element);
    }
    destroyItself() {
        if (!document.body.contains(this.element)) return;
        document.body.removeChild(this.element);
    }
}


class $3e29c386d1910a1d$export$2e2bcd8739ae039 {
    currentImage = null;
    shadows = {};
    /**
   * ============
   * Initializers
   * ============
   */ constructor({ container: container }){
        this.container = container;
        this.initOverlay();
        this.initImages();
        this.initControls();
    }
    initOverlay() {
        this.overlay = new (0, $1e566b6277893a87$export$2e2bcd8739ae039)();
        this.overlay.element.addEventListener('click', (e)=>{
            this.closeCurrent();
        });
    }
    initImages() {
        this.images = document.querySelectorAll(`${this.container} img[data-libo]`);
        function wrapInLink(image) {
            // wrap image with a link if it's not already wrapped
            const parent = image.parentElement;
            let link;
            if (!parent || parent.tagName !== 'A') {
                link = document.createElement('a');
                link.href = image.src;
                // replace image with the linked one
                parent.insertBefore(link, image);
                link.appendChild(image);
            } else link = parent;
            return link;
        }
        this.images.forEach((image)=>{
            // generate unique id for each image
            image.id = crypto.randomUUID();
            // make sure every image has a link
            const link = wrapInLink(image);
            // click link to open lightbox
            link.addEventListener('click', (e)=>{
                e.preventDefault();
                this.openLightBox(image);
            });
        });
    }
    initControls() {
        // keyboard shortcuts
        document.addEventListener('keydown', (e)=>{
            if (e.key === 'Escape' || e.key === ' ') this.closeCurrent();
        });
        // scroll to dismiss
        document.body.addEventListener('wheel', (e)=>{
            this.closeCurrent();
        });
    }
    /**
   * ============
   * Actions
   * ============
   */ openLightBox(image) {
        // hide and store original image
        image.style.visibility = 'hidden';
        this.currentImage = image;
        // get shadow of this image
        const shadow = this.shadows[image.id] || new (0, $ec04822463bc4394$export$2e2bcd8739ae039)(image);
        if (!this.shadows[image.id]) this.shadows[image.id] = shadow;
        // place and open shadow
        if (!document.body.contains(shadow.element)) shadow.placeItself();
        shadow.open();
        this.overlay.show();
    }
    closeLightBox(image) {
        // show and unstore original image
        image.style.visibility = 'visible';
        this.currentImage = null;
        // close shadow
        const shadow = this.shadows[image.id];
        if (!shadow) return;
        shadow.close();
        this.overlay.hide();
    }
    closeCurrent() {
        if (!this.currentImage) return;
        this.closeLightBox(this.currentImage);
    }
    closeAll() {
        this.images.forEach((image)=>{
            this.closeLightBox(image);
        });
        this.overlay.hide();
    }
}


export {$3e29c386d1910a1d$export$2e2bcd8739ae039 as default};
//# sourceMappingURL=lightbox.min.js.map
